{
    "$schema": "https://json-schema.org/draft-07/schema#",
    "properties": {
        "isMultiNodeCluster": {
            "type": "boolean",
            "description": "Whether we our Kubernetes cluster has multiple nodes"
        },
        "staticCpuManagerPolicy": {
            "type": "boolean",
            "description": "Whether the Kubernetes cluster has been configured with a static CPU manager policy. This is an optimization for RonDB data nodes. These have a scheduler which executes jobs within hundreds of microseconds (very quick). If the data nodes are pinned to CPUs, they can run CPU spnning to avoid context switching inbetween jobs.",
            "default": false
        },
        "terminationGracePeriodSeconds": {
            "type": "integer",
            "description": "TerminationGracePeriodSeconds for data nodes. Important for scaling down data node replicas.",
            "default": 60,
            "minimum": 30
        },
        "meta": {
            "type": "object",
            "properties": {
                "mgmd": {
                    "type": "object",
                    "properties": {
                        "statefulSetName": {
                            "type": "string"
                        },
                        "headlessClusterIp": {
                            "type": "object",
                            "properties": {
                                "name": {
                                    "type": "string"
                                },
                                "annotations": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "name"
                            ]
                        }
                    },
                    "required": [
                        "statefulSetName",
                        "headlessClusterIp"
                    ]
                },
                "mysqld": {
                    "type": "object",
                    "properties": {
                        "serviceName": {
                            "type": "string"
                        },
                        "statefulSetName": {
                            "type": "string"
                        },
                        "headlessClusterIp": {
                            "type": "object",
                            "properties": {
                                "name": {
                                    "type": "string"
                                },
                                "port": {
                                    "type": "integer"
                                },
                                "annotations": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "name",
                                "port"
                            ]
                        }
                    },
                    "required": [
                        "serviceName",
                        "statefulSetName",
                        "headlessClusterIp"
                    ]
                },
                "rdrs": {
                    "type": "object",
                    "properties": {
                        "serviceName": {
                            "type": "string"
                        },
                        "statefulSetName": {
                            "type": "string"
                        },
                        "headlessClusterIpName": {
                            "type": "string"
                        }
                    },
                    "required": [
                        "serviceName",
                        "statefulSetName",
                        "headlessClusterIpName"
                    ]
                }
            },
            "required": [
                "mgmd",
                "mysqld",
                "rdrs"
            ]
        },
        "images": {
            "type": "object",
            "description": "Information for Docker images used in the cluster",
            "properties": {
                "rondb": {
                    "$ref": "#/$defs/image"
                },
                "toolbox": {
                    "$ref": "#/$defs/image"
                }
            },
            "required": [
                "rondb",
                "toolbox"
            ]
        },
        "mysql": {
            "type": "object",
            "description": "How to initialize MySQL",
            "properties": {
                "rootCredentialsSecret": {
                    "$ref": "#/$defs/secret"
                },
                "sqlInitContent": {
                    "type": "string",
                    "description": "SQL to run *only once* at cluster startup. Try to make these scripts idempotent though, in case they are re-run by accident. Do so by e.g. using `IF NOT EXISTS` in the SQL commands."
                }
            }
        },
        "clusterSize": {
            "type": "object",
            "description": "Horizontal cluster size",
            "properties": {
                "activeDataReplicas": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 3
                },
                "numNodeGroups": {
                    "type": "integer",
                    "minimum": 1
                },
                "minNumMySQLServers": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "A minimum amount of MySQL servers"
                },
                "maxNumMySQLServers": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "The maximum amount of MySQL servers we will auto-scale to. It is represented as number of slots in RonDB's config.ini. Changing this will only take effect if the ConfigMap for config.ini is updated and the MGMd is restarted."
                },
                "minNumRdrs": {
                    "type": "integer",
                    "minimum": 0
                },
                "maxNumRdrs": {
                    "type": "integer",
                    "minimum": 0
                }
            },
            "required": [
                "activeDataReplicas",
                "numNodeGroups",
                "minNumMySQLServers",
                "maxNumMySQLServers",
                "minNumRdrs",
                "maxNumRdrs"
            ]
        },
        "resources": {
            "type": "object",
            "description": "Vertical cluster size",
            "properties": {
                "limits": {
                    "type": "object",
                    "description": "Kubernetes resource limits",
                    "properties": {
                        "cpus": {
                            "$ref": "#/$defs/cpuResources"
                        },
                        "memory": {
                            "$ref": "#/$defs/memoryResources"
                        }
                    }
                },
                "requests": {
                    "type": "object",
                    "description": "Kubernetes resource requests; Note that data nodes will only apply limits, not requests",
                    "properties": {
                        "cpus": {
                            "$ref": "#/$defs/cpuResources"
                        },
                        "memory": {
                            "$ref": "#/$defs/memoryResources"
                        },
                        "storage": {
                            "type": "object",
                            "description": "Volume sizes",
                            "properties": {
                                "storageClassName":{
                                    "type": ["string", "null"],
                                    "default": null,
                                    "description": "Storage class name to request for volumes attached to the management and the data nodes."
                                },
                                "dedicatedDiskColumnVolume":{
                                    "type": "object",
                                    "properties": {
                                        "enabled":{
                                            "type": "boolean",
                                            "default": false,
                                            "description": "Whether to use a dedicated volume only for on disk columns or not."
                                        },
                                        "storageClassName":{
                                            "type": ["string", "null"],
                                            "default": null,
                                            "description": "Storage class name to request for the disk columns volume."
                                        }
                                    }
                                },
                                "diskColumnGiB": {
                                    "type": "integer",
                                    "default": 64,
                                    "minimum": 1
                                },
                                "redoLogGiB": {
                                    "type": "integer",
                                    "default": 64,
                                    "minimum": 2,
                                    "maximum": 64
                                },
                                "undoLogsGiB": {
                                    "type": "integer",
                                    "default": 64,
                                    "minimum": 1,
                                    "maximum": 128
                                },
                                "slackGiB": {
                                    "type": "integer",
                                    "description": "Extra space for data node volumes. When RonDB allocates *exactly* the given amount of space, we can run into issues.",
                                    "default": 1,
                                    "minimum": 0,
                                    "maximum": 2
                                },
                                "logGib": {
                                    "type": "integer",
                                    "default": 2
                                }
                            }
                        }
                    }
                }
            }
        },
        "rondbConfig": {
            "type": "object",
            "description": "Configurations for RonDB's config.ini. Memory configurations are in binary SI units (i.e. 1G = 1GiB = 1024MiB).",
            "properties": {
                "MaxNoOfTables": {
                    "type": "integer"
                },
                "MaxNoOfAttributes": {
                    "type": "integer"
                },
                "MaxNoOfTriggers": {
                    "type": "integer"
                },
                "TransactionMemory": {
                    "type": "string"
                },
                "SharedGlobalMemory": {
                    "type": "string"
                },
                "ReservedConcurrentOperations": {
                    "type": "integer"
                },
                "MaxNoOfConcurrentOperations": {
                    "type": "integer"
                },
                "MySQLdSlotsPerNode": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 4
                },
                "RdrsSlotsPerNode": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 8
                },
                "EmptyApiSlots": {
                    "type": "integer",
                    "description": "For services that are not handled here, e.g. HopsFS"
                }
            },
            "required": [
                "MaxNoOfTables",
                "MaxNoOfAttributes",
                "MaxNoOfTriggers",
                "TransactionMemory",
                "SharedGlobalMemory",
                "ReservedConcurrentOperations",
                "MaxNoOfConcurrentOperations",
                "MySQLdSlotsPerNode",
                "RdrsSlotsPerNode"
            ]
        },
        "tls": {
            "type": "object",
            "description": "Whether to use encrypted connections with RonDB APIs (MySQL & RDRS). It is possible to use both Ingress and end-to-end encryption, but not recommended. Ingress encryption is recommended for most use cases. End-to-end encryption is recommended for high-security use cases.",
            "properties": {
                "ingress": {
                    "type": "object",
                    "description": "Configuration of TLS on a Kubernetes nginx-Ingress instance",
                    "properties": {
                        "enabled": {
                            "type": "boolean",
                            "description": "Whether to use an Ingress or not - we only allow Ingress with TLS. The TLS Secrets will be placed onto the Ingress instance. Ingress is currently only supported with cert-manager (RonDB-standalone) and not the certs-operator (Hopsworks-solution)."
                        },
                        "secretName": {
                            "type": "string",
                            "description": "The name of the TLS Secret the cert-manager will create for the Ingress."
                        },
                        "certificateName": {
                            "type": "string",
                            "description": "The name of the TLS Certificate we give the cert-manager to create a TLS Secret for the Ingress."
                        }
                    }
                },
                "endToEnd": {
                    "type": "object",
                    "description": "Configuration of encrypted message up until the pods. This can be done additionally to Ingress encryption, but it is recommended to use either or. End-to-end encryption is the standard solution within Hopsworks.",
                    "properties": {
                        "enabled": {
                            "type": "boolean",
                            "description": "Whether to place encryption keys on actual API pods. This will not be possible with Let's Encrypt."
                        },
                        "mysqld": {
                            "type": "object",
                            "description": "MySQLd-specific end-to-end encryption information",
                            "properties": {
                                "secretName": {
                                    "type": "string",
                                    "description": "The name of the TLS Secret name to be created by the cert-manager for the MySQLd pods."
                                }
                            }
                        },
                        "rdrs": {
                            "type": "object",
                            "description": "RDRS-specific end-to-end encryption information",
                            "properties": {
                                "secretName": {
                                    "type": "string",
                                    "description": "The name of the TLS Secret name to be created by the cert-manager for the RDRS pods."
                                }
                            }
                        }
                    }
                }
            }
        },
        "benchmarking": {
            "type": "object",
            "description": "Whether, which and how to run a benchmarking job on the cluster",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to run a benchmarking job on the cluster"
                },
                "mysqlUsername": {
                    "type": "string",
                    "description": "The MySQL user to run the benchmarks with. It will automatically be given the necessary privileges on the benchmark databases. This field is required so that benchmarking jobs can be enabled once the cluster is already running."
                },
                "credentialsSecret": {
                    "$ref": "#/$defs/secret"
                },
                "type": {
                    "description": "Which benchmarking job to run. 'Multi' refers to multiple MySQLd servers to run against",
                    "enum": [
                        "sysbench",
                        "dbt2_single",
                        "dbt2_multi"
                    ]
                },
                "dbt2": {
                    "type": "object",
                    "description": "Configuration of DBT2 benchmarking job",
                    "properties": {
                        "numWarehouses": {
                            "type": "integer",
                            "minimum": 1
                        },
                        "runSingle": {
                            "type": "string",
                            "description": "Table with columns: NUM_MYSQL_SERVERS | NUM_WAREHOUSES | NUM_TERMINALS"
                        },
                        "runMulti": {
                            "type": "string",
                            "description": "Table with columns: NUM_MYSQL_SERVERS | NUM_WAREHOUSES | NUM_TERMINALS"
                        }
                    }
                },
                "sysbench": {
                    "type": "object",
                    "description": "Configuration of Sysbench benchmarking job",
                    "properties": {
                        "threadCountsToRun": {
                            "type": "string",
                            "description": "Semi-colon-separated list of thread counts to run"
                        },
                        "rows": {
                            "type": "integer"
                        },
                        "minimizeBandwidth": {
                            "type": "boolean",
                            "default": false,
                            "description": "Whether to use filters to minimize bandwidth usage. This can be useful in cloud environments where bandwidth is expensive."
                        }
                    }
                }
            },
            "required": [
                "enabled",
                "mysqlUsername",
                "type"
            ]
        }
    },
    "required": [
        "images",
        "clusterSize",
        "resources",
        "rondbConfig"
    ],
    "$defs": {
        "secret": {
            "type": "object",
            "description": "",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the secret"
                },
                "key": {
                    "type": "string",
                    "description": "Key in the secret"
                }
            }
        },
        "cpuResources": {
            "type": "object",
            "description": "CPU resources per RonDB service type",
            "properties": {
                "mgmds": {
                    "type": "number"
                },
                "ndbmtds": {
                    "type": "number"
                },
                "mysqlds": {
                    "type": "number"
                },
                "rdrs": {
                    "type": "number"
                },
                "benchs": {
                    "type": "number"
                }
            }
        },
        "memoryResources": {
            "type": "object",
            "description": "Memory resources per RonDB service type",
            "properties": {
                "ndbmtdsMiB": {
                    "type": "number"
                },
                "mysqldMiB": {
                    "type": "number",
                    "description": "This can usually be kept at the default independent of the load"
                },
                "rdrsMiB": {
                    "type": "number"
                },
                "benchsMiB": {
                    "type": "number"
                }
            }
        },
        "image": {
            "type": "object",
            "description": "Docker image",
            "properties": {
                "registry": {
                    "type": "string",
                    "description": "Where image is hosted. Omit for local registry (E.g. use `minikube image load rondb-standalone:latest`)"
                },
                "repository": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "tag": {
                    "type": "string"
                }
            }
        }
    },
    "title": "Values",
    "type": "object"
}
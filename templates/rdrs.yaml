apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: {{ .Values.meta.rdrs.statefulSetName }}
  namespace: {{ .Release.Namespace }}
spec:
  serviceName: {{ .Values.meta.rdrs.headlessClusterIpName }}
  replicas: {{ .Values.clusterSize.minNumRdrs }}
  selector:
    # Used by the Deployment to select and manage existing pods with the specified label
    matchLabels:
      rondbService: rdrs
  template:
    metadata:
      # Used to apply labels to all pods created by the Deployment
      labels:
        rondbService: rdrs
    spec:
      {{- include "hopsworkslib.imagePullSecrets" . | indent 6 }}
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          # Preferred on different node
          - weight: 90
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: rondbService
                  operator: In
                  values:
                  - rdrs
              topologyKey: kubernetes.io/hostname
          # Preferred in different zone
          - weight: 60
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: rondbService
                  operator: In
                  values:
                  - rdrs
              topologyKey: topology.kubernetes.io/zone
      initContainers:
      - name: datanode-dependency-check
        image: {{ include "image_registry" . }}rondb-standalone:{{ .Values.image.tag }}
        command:
        - /bin/bash
        - -c
        - |
          MGMD_HOST={{ .Values.meta.mgmd.statefulSetName }}-0.{{ .Values.meta.mgmd.headlessClusterIpName }}.{{ .Release.Namespace }}.svc.cluster.local
          until nslookup $MGMD_HOST; do
            echo "Waiting for $MGMD_HOST to be resolvable..."
            sleep $(((RANDOM % 2)+2))
          done

          # Wait until data node is ready
          until ./docker/rondb_standalone/healthcheck.sh $MGMD_HOST:1186 1; do
            echo "Dependency healthcheck of ndbmtd failed. Retrying in a bit."
            sleep $(((RANDOM % 2)+2))
          done
      containers:
      - name: rdrs
        image: {{ include "image_registry" . }}rondb-standalone:{{ .Values.image.tag }}
        command:
          - /bin/bash
          - -c
          - rdrs -config=/srv/hops/mysql-cluster/rest_api.json
        ports:
          - containerPort: 4406
          - containerPort: 5406
        resources:
          limits:
            cpu: {{ .Values.resources.limits.cpus.rdrs }}
            memory: {{ .Values.resources.limits.memory.rdrsMiB }}Mi
          requests:
            cpu: {{ .Values.resources.requests.cpus.rdrs }}
            memory: {{ .Values.resources.requests.memory.rdrsMiB }}Mi
        readinessProbe:
          httpGet:
            path: "0.1.0/ping"
            port: 4406
{{ if and (.Values.tls.endToEnd.enabled)
    ( or
        (not .Values.global)
        (and .Values.global .Values.global.security.tls.enabled)
    )
}}
            scheme: HTTPS
{{ else }}
            scheme: HTTP
{{ end }}
          initialDelaySeconds: 5
          periodSeconds: 4
          failureThreshold: 1
          timeoutSeconds: 2
        livenessProbe:
          httpGet:
            path: "0.1.0/ping"
            port: 4406
{{ if and (.Values.tls.endToEnd.enabled)
    ( or
        (not .Values.global)
        (and .Values.global .Values.global.security.tls.enabled)
    )
}}
            scheme: HTTPS
{{ else }}
            scheme: HTTP
{{ end }}
          initialDelaySeconds: 5
          periodSeconds: 5
          failureThreshold: 4
          timeoutSeconds: 2
        env:
          - name: POD_NAME
            valueFrom:
              fieldRef:
                fieldPath: metadata.name
        volumeMounts:
        # Only mount single file, otherwise entire directory becomes read-only
        - name: rondb-configs
          mountPath: /srv/hops/mysql-cluster/rest_api.json
          subPath: rest_api.json
{{ if and (.Values.tls.endToEnd.enabled)
    ( or
        (not .Values.global)
        (and .Values.global .Values.global.security.tls.enabled)
    )
}}
        - name: tls-certificates
          mountPath: "/etc/tls"
          readOnly: true
{{- end }}
      # StatefulSets work with PVCs to create a dedicated persistent volume for
      # each pod replica, ensuring that a pod always re-attaches to the same data
      # even if it is rescheduled to a different node.
      volumes:
{{ if .Values.tls.endToEnd.enabled }}
    {{ if not .Values.global }}
      # This will be created by the cert-manager via the Certificate CRD
      # The RDRS will therefore not start until the certificate is available
      - name: tls-certificates
        secret:
          secretName: {{ .Values.tls.endToEnd.rdrs.secretName }}
          optional: false    
    {{ else if .Values.global.security.tls.enabled }}
      # This will be created by the certs-operator via the HopsworksCert CRD
      # The RDRS will therefore not start until the certificate is available
      - name: tls-certificates
        secret:
          secretName: "rdrs-crypto-material"
          optional: false
    {{- end }}
{{- end }}
      - name: rondb-configs
        configMap:
          name: rondb-configs
---
apiVersion: v1
kind: Service
metadata:
  name: {{ .Values.meta.rdrs.headlessClusterIpName }}
  namespace: {{ .Release.Namespace }}
spec:
  # Headless service for individual DNS records for the pods
  clusterIP: None
  # So we do not rely on the readiness probe to connect to the MGMd
  publishNotReadyAddresses: true
  # Match the spec.template.metadata.labels of the StatefulSet
  selector:
    rondbService: rdrs
  ports:
    - name: rest
      protocol: TCP
      port: 4406
      targetPort: 4406
    - name: grpc
      protocol: TCP
      port: 5406
      targetPort: 5406
---
# This is for the Ingress controller to route traffic to the RDRS
apiVersion: v1
kind: Service
metadata:
  name: {{ .Values.meta.rdrs.serviceName }}
  namespace: {{ .Release.Namespace }}
spec:
  type: ClusterIP
  selector:
    rondbService: rdrs
  ports:
    - name: rest
      protocol: TCP
      port: 4406
      targetPort: 4406
    - name: grpc
      protocol: TCP
      port: 5406
      targetPort: 5406
---
{{ if
    and (gt (.Values.clusterSize.minNumRdrs | int) 0)
    (not (eq .Values.clusterSize.minNumRdrs .Values.clusterSize.maxNumRdrs))
}}
# Cannot autosscale from 0 since no metrics to measure
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: rdrs
  namespace: {{ .Release.Namespace }}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: StatefulSet
    name: {{ .Values.meta.rdrs.statefulSetName }}
  minReplicas: {{ .Values.clusterSize.minNumRdrs }}
  maxReplicas: {{ .Values.clusterSize.maxNumRdrs }}
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
{{ end }}
---
{{ if .Values.tls.endToEnd.enabled }}
    {{ if not .Values.global }}
# Certificates will prompt the cert-manager to create a TLS Secret using the referenced
# Issuer.
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: rdrs-cert
  namespace: {{ .Release.Namespace }}
spec:
  secretName: {{ .Values.tls.endToEnd.rdrs.secretName }}
  duration: 2160h # 90d
  renewBefore: 360h # 15d
  dnsNames:
    - {{ .Values.meta.rdrs.headlessClusterIpName }}.{{ .Release.Namespace }}.svc.cluster.local
  issuerRef:
    name: selfsigned-issuer
    kind: Issuer
---
    {{ else if .Values.global.security.tls.enabled }}
# HopsworksCert will prompt the certs-operator to create a Secret using the Hopsworks CA.
apiVersion: certs.hopsworks.ai/v1alpha1
kind: HopsworksCert
metadata:
  name: rdrs
  namespace: {{ .Release.Namespace }}
  annotations:
    certs.hopsworks.ai/owned-by: service-{{ .Values.meta.rdrs.headlessClusterIpName }}
spec:
  commonName: {{ .Values.meta.rdrs.headlessClusterIpName }}.{{ .Release.Namespace }}
  locality: mysql
---
    {{ end }}
{{ end }}
